이 문제는 정말 구현 중심의 문제고, 또 효율성 테스트도 없기 때문에 바로 내가 짠 코드에 대해 설명하겠다. 이 알고리즘은 크게 세 단계로 나눌 수 있다.

첫번째 단계에서는 lock에서 비워져있는 칸들을 모두 묶을 수 있는 가장 작은 직사각형 (이른바 roi)의 규격과 위치 (가장 왼쪽 위의 칸의 좌표를 기준으로)를 찾는다. 예를 들어 lock이 [[1, 1, 1], [1, 1, 0], [1, 0, 1]]이라면, roi의 규격은 2x2에 위치는 (1, 1)이다. 이를 찾기 위해 내가 쓴 방법은 가장 왼쪽 위의 칸과 가장 오른쪽 아래의 칸의 좌표를 모든 칸들을 loop하면서 칸의 값이 0일 때 최대, 최소를 반복적으로 적용시키면서 계산한 것이다. roiXmin, roiXmax, roiYmin, roiYmax이 값들이라고 할 수 있다.

두번째 단계에서는 key가 0도, 90도, 180도, 270도 회전됐을 때의 행렬을 새로 생성한 리스트에 저장한다. 직각 회전이 아닌 경우, key의 칸과 lock의 칸이 들어맞지 않으므로 무시할 수 있기 때문이다. 시계방향이든, 반시계방향이든 모양은 똑같이 나오므로, 총 4개의 행렬이 나온다. key를 회전시키는 방법으로는 python의 numpy 모듈을 활용했다. 다른 방법으로는, 좌표를 90도 회전시키는 식을 구하고, 그 식을 이용해서 transition matrix를 만들어서 곱하는 것도 있을테지만, 연필과 종이를 쓰고 싶지 않았다 ㅎㅎ.

세번째 단계에서는 첫번째에서 구한 roi의 위치와 규격을 이용해서 lock의 어느 부분에 두번째 단계에서 구한 행렬(회전된 key들)이 들어맞는지를 확인하는 것이다. 예를 들어 lock이 [[1, 1, 1], [1, 1, 0], [1, 0, 1]]이고, key가 [[0, 0, 0], [1, 0, 0], [0, 1, 1]]이라면, roi가 2x2에 (1, 1)이었으므로, 키를 lock에 꽂아보는 연산은 key와 lock의 위치가 동일할 때, key가 lock보다 오른쪽 한칸에 있을 때, 아래로 한칸에 있을 때, 오른쪽 한칸과 왼쪽 한칸에 있을 때로 총 4가지로 나눠지고, 이 각각의 경우에 대해 key를 회전시켜보면 된다. 그렇게 lock에 들어맞는 키를 찾으면, true를 리턴하고, 계산해야할 모든 경우를 탐색했음에도 찾을 수 없었다면 false를 리턴하도록 했다.
