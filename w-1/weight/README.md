이 문제를 푸는 방법은 여러가지가 있을겁니다. Dfs와 dp를 이용해서 풀 수도 있고, while 문을 돌려서 1부터 weight 리스트 안의 원소들의 합 더하기 1까지 일일이 확인해보는 방법도 있을겁니다. 하지만 이 문제에서는 상당히 까다로운 효율성을 요구하고, 따라서 저의 최종코드는 O(nlogn)의 시간복잡도를 가지게 되었습니다. 최종코드의 핵심논리는 다음과 같습니다.

weight의 원소들을 subset으로 묶어주는데, 그 원소의 크기대로 순차적으로 묶어줄 수 있습니다. 예를 들어, [3, 1, 6, 2, 7, 30, 1]을 weight라고 칩시다. 이 weight를 오름차순으로 정렬하면, [1, 1, 2, 3, 6, 7, 30]이 될 것이고, 이를 바탕으로 앞서 언급한 subset을 만들어주면, [1], [1, 1], [1, 1, 2], [1, 1, 2, 3], … [1, ..., 30] 이런 식으로 됩니다. 이 subset들은 특정 조건이 만족될 때 한 특징이 있는데, 각각의 원소들의 합이 n이라고 치면, 이 원소들의 부분합으로 1부터 n까지 모두 표현 가능하다는 것입니다. 예를 들어, subset [1, 1, 2, 3]은 1부터 7까지를 모두 원소들의 부분합으로 나타낼 수 있습니다. 

그렇다면, 이 특정조건은 무엇이며, 이 특징은 대체 어떻게 성립하는 걸까요? 특정조건을 이해하게 되면, 이 특징이 성립하는 이유도 자연스럽게 알게 됩니다. 우선 특정조건에 대해 말씀드리자면, subset들의 원소들은 그 이전의 모든 원소들의 합보다 작거나 같거나 혹은 1 커야한다는 것입니다. 그래야만 앞서 언급된 특징이 성립한다는 것이죠. 다시 예를 들어 [1, 1, 2, 3, 6, 7, 30] 리스트의 경우, 1+1+2+3+6+7은 20으로써, 마지막 원소인 30은 20보다 크므로, 이 리스트는 이 특징을 따르지 않습니다. 왜냐하면 21부터 29까지의 수를 이 리스트의 부분합으로 나타낼 방법이 없기 때문이죠. 20까지는 1+1+2+3+6+7를 하면 나오지만, 21부터는 이를 더해서 나타낼 원소가 없습니다. 하지만 만약 위의 리스트가 [1, 1, 2, 3, 6, 7, 21] 이라면, 20까지 표현하고, 21은 그냥 원소 21을 쓰면 됩니다. 22의 경우 21+1을 하면 되고, 같은 방식으로 20까지 표현하는데 썼던 부분합의 방식에다가 21이라는 원소만 더해주면 41까지의 수를 표현할 수 있게 되는 것입니다. 앞서 언급한 특징이 성립하는 이유가 여기에 있습니다. 매우 재귀적인 관계를 띄는 특징이고, 조건이라고 할 수 있겠습니다. 위의 리스트 [1, 1, 2, 3, 6, 7, 30]은 따라서 21이 출력값(원소들의 부분합으로 나타낼 수 없는 가장 작은 양의 정수) 이라고 결론지을 수 있습니다. 이 리스트의 마지막 원소가 21보다 작거나 같은 k라는 수였으면, 이 리스트의 출력값은 20+k+1이었을 겁니다. 이해가 가시나요?

따라서 알고리즘은 총 3가지의 단계를 거칩니다.

첫번째로는, weight 리스트를 오름차순으로 정렬합니다.

두번째는, weight 리스트의 원소 부분합을 각각의 원소로 가지고 있는 새로운 리스트 nums를 만들어줍니다.

세번째로는, 이 nums 리스트 안의 원소 +1을 한 값인 v가 같은 인덱스에 있는 weight의 원소보다 작거나 같은지를 확인합니다. 만약 더 크다면, v를 리턴하도록 합니다. 이 loop에서 v가 리턴되지 않았다면, weight 리스트 원소 전체의 합, 즉 nums의 마지막 원소 +1 한 값을 리턴하도록 합니다.

이 과정은 순서대로, O(nlogn), O(n), O(n)의 과정을 거칩니다. 따라서 총합은 O(nlogn)인 것이죠.
